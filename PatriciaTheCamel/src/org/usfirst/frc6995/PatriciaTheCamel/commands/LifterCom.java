// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc6995.PatriciaTheCamel.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc6995.PatriciaTheCamel.Robot;
import org.usfirst.frc6995.PatriciaTheCamel.commands.RiserUpdateMonitor;
import java.lang.Math;

/**
 *
 */
public class LifterCom extends Command {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
 
    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_DECLARATIONS
	static final int DEST_ANGLE_OVERRIDE_INVALID = -1;
	static int destAngleOverrideIndex = DEST_ANGLE_OVERRIDE_INVALID;
	
	private int destHeightEnc;
	private int destAngleEnc;
	private boolean ignoreAngleOverride;
	private boolean allowRiserControl;
	private RiserUpdateMonitor riserUpdateMonitor;
	
	private int heightInchToEnc(double heightInch) {
		heightInch = Math.max(-0.5, Math.min(heightInch, 81.0));
		return (int)(heightInch/100);  //REVISIT: This assumes 0.25 inch/link of chain; 16 cog sprocket; 400 enc counts/inch
	}
	
	private int angleDegToEnc(double angleDeg) {
		angleDeg = Math.max(-150.0, Math.min(angleDeg, 150.0));
		return (int)(angleDeg * 1024.0 / 360.0);
	}
	
	// LifterCom(double destHeightInch, double destAngleDeg)
	// Used for commanding going to a specific height at specific angle,
	// subject to mechanical interference constraints.
	// Destination angle may be overridden by default,
	// but should be suppressed if this is not the last lifter command in a sequence.
	// This does not support manual riser control.
	// This command does not automatically terminate by default to provide calls supporting angle overrides.
    public LifterCom(double destHeightInch, double destAngleDeg) {
    	this.destHeightEnc = this.heightInchToEnc(destHeightInch);
    	this.destAngleEnc = this.angleDegToEnc(destAngleDeg);
    	this.ignoreAngleOverride = false;
    	this.allowRiserControl = false;
    	requires(Robot.lifter);
    }
    
    // LifterCom(RiserUpdateMonitor monitor)
    // used for commanding the riser going in a relative direction
    // while the monitor interface calls return up (>0), down (<0), or stationary (0) values.
    // The angle will be controlled through the override.
    // Upon activation, this routine is initialized to the current height and angle.
    
    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    public LifterCom(RiserUpdateMonitor monitor) {
    	this.destHeightEnc = this.heightInchToEnc(0.0);
    	this.destAngleEnc = this.angleDegToEnc(0.0);
    	this.ignoreAngleOverride = false;
    	this.allowRiserControl = true;
    	this.riserUpdateMonitor = monitor;
        requires(Robot.lifter);
    }
	
    
    // Use default for homing/dirty powerup?
	public LifterCom() {

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTRUCTOR
    	this.destHeightEnc = this.heightInchToEnc(0.0);
    	this.destAngleEnc = this.angleDegToEnc(0.0);
    	this.ignoreAngleOverride = false;
    	this.allowRiserControl = false;
    	
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=VARIABLE_SETTING
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        requires(Robot.lifter);

        // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=REQUIRES
        
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	destAngleOverrideIndex = DEST_ANGLE_OVERRIDE_INVALID; // Prevent seeing old values
    	isInterruptible();
    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	
    	if (this.allowRiserControl) {
    		int riserUpdate = this.riserUpdateMonitor.riserUpdateMonitor();
    		if (0 != riserUpdate) {
    			// Try to go up if value is >0; Try to go down if value is <0
    		}
    	}
    	
    	// First determine if any override index applies
    	int destAngleEnc = this.destAngleEnc;
    	if (!ignoreAngleOverride &&
    		    destAngleOverrideIndex != DEST_ANGLE_OVERRIDE_INVALID) {
    		int angleOverrideDeg[] = { 0, 45, 90, 135, 180, -135, -90, -45 };
    		int idx = Math.max(0, Math.min(angleOverrideDeg.length - 1, destAngleOverrideIndex));
    		destAngleEnc = angleDegToEnc(angleOverrideDeg[idx]);
    	}
    	
    	// Then determine the available angles at the look-ahead height
    	
    	// If we are not (yet) at an allowable angle for the upcoming height,
    	// then we need to go to an allowable angle (even if it means we need
    	// to turn away from our destination angle due to constraints.
    	//
    	// TODO: update heading to go toward our upcoming angle
    	
    	// If we can move forward then move toward our upcoming height

    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return false;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();
    }
    
    // Called to update the override value
    public static void setDestAngleOverrideIndex(int index) {
    	destAngleOverrideIndex = index;
    }
}
