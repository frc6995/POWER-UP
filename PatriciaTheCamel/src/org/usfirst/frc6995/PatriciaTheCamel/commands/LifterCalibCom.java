// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc6995.PatriciaTheCamel.commands;
import edu.wpi.first.wpilibj.command.Command;
import org.usfirst.frc6995.PatriciaTheCamel.Robot;

/**
 *
 */
public class LifterCalibCom extends Command {

	// Observations: Operation needs to monitor both motors
	// to determine when they are stopped, then move on to the next sequence.
	// Need commands to do the following with or without the encoder:
	// - Move Up & Out until both encoders are stopped for 0.1s or timeout has passed
	// - Move Dn & Out until both encoders are stopped for 0.1s or timeout has passed
	// - Move Dn & In  until both encoders are stopped for 0.1s or timeout has passed
	// - Reset both encoders
	// - Move Up & Out a relative distance. Wait until both encoders are stopped for 0.1s or timeout has passed
	// - Reset both encoders - This is Riser 0, Rotator 0.
	
	final private int riserUpDeltaEnc;
	final private int rotatorOutDeltaEnc;
	final private int settleCycles;
	final private int abortCycles;
	
	private int remainingCycles;
	private int remainingSettleCycles;
	private int lastRiserEnc;
	private int lastRotatorEnc;
	private int startRiserEnc;
	private int startRotatorEnc;

	public LifterCalibCom(int riserUpDeltaEnc, int rotatorOutDeltaEnc, int settleCycles, int abortCycles) {

		this.riserUpDeltaEnc = riserUpDeltaEnc;
		this.rotatorOutDeltaEnc = rotatorOutDeltaEnc;
		this.settleCycles = settleCycles;
		this.abortCycles = abortCycles;
		
		this.remainingCycles = 0;
		this.remainingSettleCycles = 0;
		this.startRiserEnc = 0;
		this.startRotatorEnc = 0;
		
		requires(Robot.lifter);
	}
	
	// This command command directs motors to move in the indicated direction
	public LifterCalibCom(boolean riserUp, boolean rotatorOut, int forCycles) {
		
		this(
				(riserUp) ? Integer.MAX_VALUE : Integer.MIN_VALUE, // riserUpDeltaEnc
				(rotatorOut) ? Integer.MAX_VALUE : Integer.MIN_VALUE, // rotatorOutDeltEnc
				-1, // settlingCounts - negative indicates use time drive instead of monitoring encoder
				forCycles);
	}
	
	
	// The default command resets the encoders to the current position.
    public LifterCalibCom() {

        this(0, 0, -1, 1);  // Basically, reset the encoders on first run
    }

    // Called just before this Command runs the first time
    @Override
    protected void initialize() {
    	this.remainingCycles = this.abortCycles;
    	this.remainingSettleCycles = this.settleCycles;
    	
    	if (0 <= this.settleCycles) {
    		this.startRiserEnc = 1;  // TODO Read the initial encoder value
    		this.startRotatorEnc = 1;  // TODO Read the initial encoder value
    	}

    }

    // Called repeatedly when this Command is scheduled to run
    @Override
    protected void execute() {
    	
    	this.remainingCycles = Math.max(0, this.remainingCycles - 1);
    	
    	// If we have encoders to monitor feedback, do so
    	if (0 <= this.settleCycles) {
    		
	    	final int riserEnc = 0; // TODO Read riser position
	    	final int rotatorEnc = 0;  // TODO Read rotator position
	    	
	    	if (riserEnc == this.lastRiserEnc && rotatorEnc == this.lastRotatorEnc) {
	    		this.remainingSettleCycles = Math.max(0, this.remainingSettleCycles - 1);
	    	}
	    	else {
	    		this.remainingSettleCycles = this.settleCycles;
	    		this.lastRiserEnc = riserEnc;
	    		this.lastRotatorEnc = rotatorEnc;
	    	}
	    	
	    	// TODO Command each motor to move for a short distance toward our destination
	    	if (this.riserUpDeltaEnc >= 0) {
	    		int remainingDeltaEnc = this.riserUpDeltaEnc - (riserEnc - this.startRiserEnc);
	    		remainingDeltaEnc = Math.min(remainingDeltaEnc, 20);
	    		
	    		// TODO Tell the motor to move forward the indicated amount.
	    	}
	    	else {
	    		int remainingDeltaEnc = this.riserUpDeltaEnc - (riserEnc - this.startRiserEnc);
	    		remainingDeltaEnc = Math.max(remainingDeltaEnc, -20);

	    		// TODO Tell the motor to move forward the indicated amount.
	    	}
	    	
	    	if (this.rotatorOutDeltaEnc >= 0) {
	    		int remainingDeltaEnc = this.rotatorOutDeltaEnc - (rotatorEnc - this.startRotatorEnc);
	    		remainingDeltaEnc = Math.min(remainingDeltaEnc, 5);
	    		
	    		// TODO Tell the motor to move forward the indicated amount.
	    	}
	    	else {
	    		int remainingDeltaEnc = this.rotatorOutDeltaEnc - (rotatorEnc - this.startRotatorEnc);
	    		remainingDeltaEnc = Math.max(remainingDeltaEnc, -5);

	    		// TODO Tell the motor to move forward the indicated amount.
	    	}
	    	
    	}
    	else {
    		// REVISIT: Without encoders can we still check for a motor stall condition?
    		//          Are these motors too powerful to stall out against a wall?  (Seems so.)
    		// TODO Command each motor to move for a short amout of time (~ 1/2 second) in the indicated direction
    	}
    }

    // Make this return true when this Command no longer needs to run execute()
    @Override
    protected boolean isFinished() {
        return this.remainingCycles <= 0 || this.remainingSettleCycles <= 0;
    }

    // Called once after isFinished returns true
    @Override
    protected void end() {
    	// TODO Reset the encoders
    }

    // Called when another command which requires one or more of the same
    // subsystems is scheduled to run
    @Override
    protected void interrupted() {
    	end();  // Not expected to be needed, but just to be safe
    }
}
